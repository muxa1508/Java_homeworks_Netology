### Задание 1 (обязательное)
Перед вами классический для графического дизайна текст `Lorem Ipsum`:

```
Lorem ipsum dolor sit amet, consectetur adipiscing elit, 
sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. 
Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris 
nisi ut aliquip ex ea commodo consequat. 
Duis aute irure dolor in reprehenderit in voluptate velit 
esse cillum dolore eu fugiat nulla pariatur. 
Excepteur sint occaecat cupidatat non proident, 
sunt in culpa qui officia deserunt mollit anim id est laborum.
```

Вам нужно определить, какая буква встречалась в нём чаще всего и какая реже всего. 
Определить, является ли символ буквой, можно с помощью встроенного статического метода `Character.isLetter` 
(поэкспериментируйте с ним, если сходу непонятно как им пользоваться или загуглите на него 
документацию - уже пора развивать этот навык).
Считать, конечно, нужно не руками. Заведите в `Main` статическое текстовое поле с содержимым из текста выше, 
а в `main` напишите программу, решающую поставленную задачу.

**Подсказки**
Заведите мапу `Map<Character, Integer>`, в которой для каждого символа будете хранить количество раз, 
которое вы его встретили. Изначально мапа пустая. `Character` это ссылочный тип-обёртка для `char`, как `Integer` для `int`.

Пройдитесь циклом по символам строки. Символы можно получать по индексу с помощью метода `.charAt(ИНДЕКС)`. 
Для каждого символа проверьте, есть ли он в мапе. Может быть два случая:

Его нет в мапе. Значит, мы встретили его в первый раз и вставляем в мапу пару где ключ это наш символ, 
а значение это `1` (тк встретили его всего один раз).
Он есть в мапе. Значит он нам уже встречался. Вынимаем текущее значение для ключа (нашего символа), 
увеличиваем это число на 1 и вставляем обратно в мапу.
В итоге после цикла у нас будет мапа частот с которой встречаются символы.

Всё что нам останется - пройтись по этой мапе и найти максимум и минимум. 
Находить максимум в последовательности вы уже умеете, останется только адаптировать эту логику для 
поиска не в массиве, а проходясь по мапе. Поиск минимума абсолютно аналогичен (только вместо `-1` 
возьмите `Integer.MAX_VALUE` - максимальное значение которое может быть у `int`).

### Задание 2 (обязательное)
Эта задача делается в новом репозитории. Мы будем писать систему, которая будет быстро отвечать на вопрос, 
есть ли вводимое слово в тексте.

Создайте класс `WordsChecker` (англ. проверятель слов). Пусть у него будет конструктор, в который 
передаётся текст, в котором мы будем проверять наличие слов.

Кроме конструктора у него должен быть метод `hasWord`, куда передаётся слово и который возвращает ответ на вопрос `(boolean)` о 
том, есть ли это слово в тексте или нет.

При этом это должно делаться эффективно - простым `text.contains(word)` не обойтись, т.к. 
это медленный полный перебор всего текста. Вам предлагается разбить текст на слова 
(воспользуйтесь `text.split("\\P{IsAlphabetic}+");` для этого) и положить их в коллекцию для 
быстрой проверки наличия в ней слов через специальный метод коллекции. 
Подумайте что это за коллекция должна быть и какой метод тут подойдёт.

Продемонстрируйте работу вашего класса в `Main` на примере текста `Lorem ipsum` из первого задания.